<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>GPStream Chipset Library: RXN_CL.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>RXN_CL.h File Reference</h1>
<p>Chipset Library (CL) programming interface for Rx Networks technologies.  
<a href="#_details">More...</a></p>
<code>#include &quot;RXN_data_types.h&quot;</code><br/>
<code>#include &quot;RXN_constants.h&quot;</code><br/>
<code>#include &quot;RXN_structs.h&quot;</code><br/>
<code>#include &quot;RXN_debug.h&quot;</code><br/>
<code>#include &quot;RXN_MSL.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="RXN__CL_8h.html">RXN_CL_Constants.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRXN__CL__FixData__t.html">RXN_CL_FixData_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Struct describing fix data.  <a href="structRXN__CL__FixData__t.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="RXN__CL_8h.html#a771ea75bb55563f40ba2f3b07634020e">RXN_CL_Restarts_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="RXN__CL_8h.html#a771ea75bb55563f40ba2f3b07634020ea6c8c3f81ea8e9d5d19036ddb4d7534ba">RXN_CL_NO_RESTART</a> =  0, 
<br/>
&nbsp;&nbsp;<a class="el" href="RXN__CL_8h.html#a771ea75bb55563f40ba2f3b07634020eacc33bdb73fc7bfba596b1193b860da81">RXN_CL_CLEAR_ALL_RESTART</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="RXN__CL_8h.html#a771ea75bb55563f40ba2f3b07634020ea2e7a06c5f1bb432ab2370184f6e7dbd9">RXN_CL_COLD_RESTART</a> =  RXN_CL_CLEAR_ALL_RESTART, 
<br/>
&nbsp;&nbsp;<a class="el" href="RXN__CL_8h.html#a771ea75bb55563f40ba2f3b07634020ea8127ef0bd4ac7dbfde490729aa082b22">RXN_CL_CLEAR_EPHEMERIS_RESTART</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="RXN__CL_8h.html#a771ea75bb55563f40ba2f3b07634020ea5626de8dcf67647da993f153dbf13ea9">RXN_CL_WARM_RESTART</a> =  RXN_CL_CLEAR_EPHEMERIS_RESTART, 
<br/>
&nbsp;&nbsp;<a class="el" href="RXN__CL_8h.html#a771ea75bb55563f40ba2f3b07634020ea1adfa9d57ca6951e9630c6a8d86b2105">RXN_CL_CLEAR_NOTHING_RESTART</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="RXN__CL_8h.html#a771ea75bb55563f40ba2f3b07634020ea82579937fb1b5dd859698d9c78c6cbea">RXN_CL_HOT_RESTART</a> =  RXN_CL_CLEAR_NOTHING_RESTART, 
<br/>
&nbsp;&nbsp;<a class="el" href="RXN__CL_8h.html#a771ea75bb55563f40ba2f3b07634020eaeb67861d3423d9355344d2071cc53759">RXN_CL_CLEAR_TIME</a> =  (1&lt;&lt;2), 
<br/>
&nbsp;&nbsp;<a class="el" href="RXN__CL_8h.html#a771ea75bb55563f40ba2f3b07634020eaa5909458dc6e15ffa0c5259845609d74">RXN_CL_CLEAR_POSITION</a> =  (1&lt;&lt;3), 
<br/>
&nbsp;&nbsp;<a class="el" href="RXN__CL_8h.html#a771ea75bb55563f40ba2f3b07634020ea0ebb8df9eec48a68f30b89602969409d">RXN_CL_CLEAR_EPHEMERIS</a> =  (1&lt;&lt;4), 
<br/>
&nbsp;&nbsp;<a class="el" href="RXN__CL_8h.html#a771ea75bb55563f40ba2f3b07634020eab6bb57808c1a637c0ad0203d9593c8b5">RXN_CL_CLEAR_ALMANAC</a> =  (1&lt;&lt;5), 
<br/>
&nbsp;&nbsp;<a class="el" href="RXN__CL_8h.html#a771ea75bb55563f40ba2f3b07634020ea79d54223c64e29330032d228c22af411">RXN_CL_ASSIST_EXEPHEMERIS</a> =  (1&lt;&lt;6), 
<br/>
&nbsp;&nbsp;<a class="el" href="RXN__CL_8h.html#a771ea75bb55563f40ba2f3b07634020ea125a7ffb6fc05d6a211d8372dee07020">RXN_CL_ASSIST_LOC</a> =  (1&lt;&lt;7), 
<br/>
&nbsp;&nbsp;<a class="el" href="RXN__CL_8h.html#a771ea75bb55563f40ba2f3b07634020ea2ccb6081b748794bbb3c37f8a4bb6fbe">RXN_CL_ASSIST_TIME</a> =  (1&lt;&lt;8), 
<br/>
&nbsp;&nbsp;<a class="el" href="RXN__CL_8h.html#a771ea75bb55563f40ba2f3b07634020eaa2ac10911737931dc7eb6b823bdf9318">RXN_CL_RESTART_END</a> =  ((1&lt;&lt;9) + 1)
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Enumeration of the currently supported reset or restart types. </p>
 <a href="RXN__CL_8h.html#a771ea75bb55563f40ba2f3b07634020e">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="RXN__CL_8h.html#a4ebd1cdaa2b228aaa4914114f6a2d84d">RXN_CL_ClkOffsetChange_CB</a> (S32 newOffset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notifies of an offset change (current GPS time from the receiver - GPS time calculated from RTC).  <a href="#a4ebd1cdaa2b228aaa4914114f6a2d84d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="RXN__CL_8h.html#afbc36ae58a898507d225fb4df226997d">RXN_CL_FullToRXN</a> (RXN_FullEph_t *pFull, RXN_ephem_t *pRXN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert ephemeris data (full ephemeris to RXN ephemeris).  <a href="#afbc36ae58a898507d225fb4df226997d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">U16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="RXN__CL_8h.html#a90d6683386a410106ad5b46823c55e3f">RXN_CL_Get_API_Version</a> (char version[RXN_CONSTANT_VERSION_STRING_LENGTH])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the Chipset Lib (CL) API version.  <a href="#a90d6683386a410106ad5b46823c55e3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">U16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="RXN__CL_8h.html#aa817c8bcd4e54fdbf8dc0f60922b8251">RXN_CL_Get_Chipset</a> (char chipset[RXN_CL_CHIP_MAX_STR_LEN])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve a chipset descriptor from the library (for which it has been compiled).  <a href="#aa817c8bcd4e54fdbf8dc0f60922b8251"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">U16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="RXN__CL_8h.html#a059221097d784a0626fd7a5d4e002684">RXN_CL_Get_Chipset_Support_Version</a> (U16 handle, char version[RXN_CONSTANT_VERSION_STRING_LENGTH])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve version info from the chipset.  <a href="#a059221097d784a0626fd7a5d4e002684"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="RXN__CL_8h.html#a24b70895edb449b3ca615a22cb48fceb">RXN_CL_GetAssistance</a> (U08 assistTypeBitMask, U32 gpsPrnBitMask, U32 gloSlotBitMask)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get assistance.  <a href="#a24b70895edb449b3ca615a22cb48fceb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">S32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="RXN__CL_8h.html#accbe073860c5725df7fb63fce99fe9a0">RXN_CL_GetClkOffset</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the offset between RTC time and GPS time maintained within the CL.  <a href="#accbe073860c5725df7fb63fce99fe9a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">U16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="RXN__CL_8h.html#ad2ae745ab295c1a07a21b9898a760784">RXN_CL_GetFixData</a> (U16 handle, <a class="el" href="structRXN__CL__FixData__t.html">RXN_CL_FixData_t</a> *pFixData)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get fix data.  <a href="#ad2ae745ab295c1a07a21b9898a760784"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">U16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="RXN__CL_8h.html#acaefe7d06443dfb0337f97521805d4db">RXN_CL_GetGPSMeasSet</a> (RXN_GPSMsrSetList_t *MeasSetElements)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets GPS measurement sets including pseudo range data.  <a href="#acaefe7d06443dfb0337f97521805d4db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">U16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="RXN__CL_8h.html#a5557b6480519e4eb9de97f6587fbe017">RXN_CL_GetGPSRcvrTime</a> (U16 handle, U16 *pRcvrWeekNum, U32 *pRcvrTOW)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current GPS time from the reciever (after the reciver fixes).  <a href="#a5557b6480519e4eb9de97f6587fbe017"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">U16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="RXN__CL_8h.html#a92e14faace538133eae58594f2aa4907">RXN_CL_Initialize</a> (U16 chipsetVer, char config[RXN_CL_CONFIG_MAX_STR_LEN], U16 *phandle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the CL library for use with a specific chipset and version of chipset support.  <a href="#a92e14faace538133eae58594f2aa4907"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">U16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="RXN__CL_8h.html#a11f29e760166343c13785b36451689a0">RXN_CL_Log_Init</a> (const char logFile[RXN_CL_MAX_LOG_PATH])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a log for CL library use.  <a href="#a11f29e760166343c13785b36451689a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="RXN__CL_8h.html#aa29c0f302ecbd4cf395cf08a1159c05a">RXN_CL_Log_UnInit</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Un-Initialize a log that has been opened for CL library use.  <a href="#aa29c0f302ecbd4cf395cf08a1159c05a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">U16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="RXN__CL_8h.html#ae417df1e3e41fcb71ade1b34d2e82058">RXN_CL_ReadEphemeris</a> (U16 handle, RXN_MSL_NavDataList_t *pNavDataList, RXN_constel_t constel)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read broadcast ephemeris data.  <a href="#ae417df1e3e41fcb71ade1b34d2e82058"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">U16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="RXN__CL_8h.html#ade314c9e8cc5b198dfda90f4985efd1a">RXN_CL_Restart</a> (U16 handle, <a class="el" href="RXN__CL_8h.html#a771ea75bb55563f40ba2f3b07634020e">RXN_CL_Restarts_t</a> restartType, RXN_RefLocation_t *pRefLoc, RXN_RefTime_t *pRefTime)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restart the chipset.  <a href="#ade314c9e8cc5b198dfda90f4985efd1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="RXN__CL_8h.html#aadbe9bfd94f7536dbcd53c4db691feaa">RXN_CL_RXNToFull</a> (RXN_ephem_t *pRXN, RXN_FullEph_t *pFull, U08 CAOrPOnL2, U16 iodc, U08 L2PData, S08 TGD, U08 AODO)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert ephemeris data (RXN ephemeris to full ephemeris).  <a href="#aadbe9bfd94f7536dbcd53c4db691feaa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">U16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="RXN__CL_8h.html#a72527b125130326a68f1bc1331309ef1">RXN_CL_SetRefLocTime</a> (U16 handle, RXN_RefLocation_t *pRefLoc, RXN_RefTime_t *pRefTime)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a reference location and/or time within the chipset.  <a href="#a72527b125130326a68f1bc1331309ef1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">U16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="RXN__CL_8h.html#af0c5d6d1b7b92d394c3287b97f38f5f9">RXN_CL_Uninitialize</a> (U16 handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">UnInitialize a CL library instance.  <a href="#af0c5d6d1b7b92d394c3287b97f38f5f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">U16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="RXN__CL_8h.html#a0680122568e9398d1a05abefd34faee3">RXN_CL_Work</a> (U16 handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Give the chipset CL implementation time to perform periodic tasks.  <a href="#a0680122568e9398d1a05abefd34faee3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">U16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="RXN__CL_8h.html#a8b09f50528981195bd1b115b7692b050">RXN_CL_WriteEphemeris</a> (U16 handle, RXN_MSL_NavDataList_t *pNavDataList, RXN_constel_t constel)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write extended ephemeris data.  <a href="#a8b09f50528981195bd1b115b7692b050"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Chipset Library (CL) programming interface for Rx Networks technologies. </p>
<p>The CL is used to provide a common interface for a variety of chipsets. Any chipset supporting this common interface can easily be plugged into Rx Networks applications or any other applications supporting the interface. </p>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a771ea75bb55563f40ba2f3b07634020e"></a><!-- doxytag: member="RXN_CL.h::RXN_CL_Restarts_t" ref="a771ea75bb55563f40ba2f3b07634020e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="RXN__CL_8h.html#a771ea75bb55563f40ba2f3b07634020e">RXN_CL_Restarts_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enumeration of the currently supported reset or restart types. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a771ea75bb55563f40ba2f3b07634020ea6c8c3f81ea8e9d5d19036ddb4d7534ba"></a><!-- doxytag: member="RXN_CL_NO_RESTART" ref="a771ea75bb55563f40ba2f3b07634020ea6c8c3f81ea8e9d5d19036ddb4d7534ba" args="" -->RXN_CL_NO_RESTART</em>&nbsp;</td><td>
<p>No receiver restart. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a771ea75bb55563f40ba2f3b07634020eacc33bdb73fc7bfba596b1193b860da81"></a><!-- doxytag: member="RXN_CL_CLEAR_ALL_RESTART" ref="a771ea75bb55563f40ba2f3b07634020eacc33bdb73fc7bfba596b1193b860da81" args="" -->RXN_CL_CLEAR_ALL_RESTART</em>&nbsp;</td><td>
<p>Restart without time, position, ephemeris, Almanac </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a771ea75bb55563f40ba2f3b07634020ea2e7a06c5f1bb432ab2370184f6e7dbd9"></a><!-- doxytag: member="RXN_CL_COLD_RESTART" ref="a771ea75bb55563f40ba2f3b07634020ea2e7a06c5f1bb432ab2370184f6e7dbd9" args="" -->RXN_CL_COLD_RESTART</em>&nbsp;</td><td>
<p>Cold receiver restart. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a771ea75bb55563f40ba2f3b07634020ea8127ef0bd4ac7dbfde490729aa082b22"></a><!-- doxytag: member="RXN_CL_CLEAR_EPHEMERIS_RESTART" ref="a771ea75bb55563f40ba2f3b07634020ea8127ef0bd4ac7dbfde490729aa082b22" args="" -->RXN_CL_CLEAR_EPHEMERIS_RESTART</em>&nbsp;</td><td>
<p>Restart without ephemeris </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a771ea75bb55563f40ba2f3b07634020ea5626de8dcf67647da993f153dbf13ea9"></a><!-- doxytag: member="RXN_CL_WARM_RESTART" ref="a771ea75bb55563f40ba2f3b07634020ea5626de8dcf67647da993f153dbf13ea9" args="" -->RXN_CL_WARM_RESTART</em>&nbsp;</td><td>
<p>Warm reciever restart. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a771ea75bb55563f40ba2f3b07634020ea1adfa9d57ca6951e9630c6a8d86b2105"></a><!-- doxytag: member="RXN_CL_CLEAR_NOTHING_RESTART" ref="a771ea75bb55563f40ba2f3b07634020ea1adfa9d57ca6951e9630c6a8d86b2105" args="" -->RXN_CL_CLEAR_NOTHING_RESTART</em>&nbsp;</td><td>
<p>REstart without clear anything </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a771ea75bb55563f40ba2f3b07634020ea82579937fb1b5dd859698d9c78c6cbea"></a><!-- doxytag: member="RXN_CL_HOT_RESTART" ref="a771ea75bb55563f40ba2f3b07634020ea82579937fb1b5dd859698d9c78c6cbea" args="" -->RXN_CL_HOT_RESTART</em>&nbsp;</td><td>
<p>Hot receiver restart. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a771ea75bb55563f40ba2f3b07634020eaeb67861d3423d9355344d2071cc53759"></a><!-- doxytag: member="RXN_CL_CLEAR_TIME" ref="a771ea75bb55563f40ba2f3b07634020eaeb67861d3423d9355344d2071cc53759" args="" -->RXN_CL_CLEAR_TIME</em>&nbsp;</td><td>
<p>Clear time </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a771ea75bb55563f40ba2f3b07634020eaa5909458dc6e15ffa0c5259845609d74"></a><!-- doxytag: member="RXN_CL_CLEAR_POSITION" ref="a771ea75bb55563f40ba2f3b07634020eaa5909458dc6e15ffa0c5259845609d74" args="" -->RXN_CL_CLEAR_POSITION</em>&nbsp;</td><td>
<p>Clear Position </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a771ea75bb55563f40ba2f3b07634020ea0ebb8df9eec48a68f30b89602969409d"></a><!-- doxytag: member="RXN_CL_CLEAR_EPHEMERIS" ref="a771ea75bb55563f40ba2f3b07634020ea0ebb8df9eec48a68f30b89602969409d" args="" -->RXN_CL_CLEAR_EPHEMERIS</em>&nbsp;</td><td>
<p>Clear ephemeris </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a771ea75bb55563f40ba2f3b07634020eab6bb57808c1a637c0ad0203d9593c8b5"></a><!-- doxytag: member="RXN_CL_CLEAR_ALMANAC" ref="a771ea75bb55563f40ba2f3b07634020eab6bb57808c1a637c0ad0203d9593c8b5" args="" -->RXN_CL_CLEAR_ALMANAC</em>&nbsp;</td><td>
<p>Clear Almanac </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a771ea75bb55563f40ba2f3b07634020ea79d54223c64e29330032d228c22af411"></a><!-- doxytag: member="RXN_CL_ASSIST_EXEPHEMERIS" ref="a771ea75bb55563f40ba2f3b07634020ea79d54223c64e29330032d228c22af411" args="" -->RXN_CL_ASSIST_EXEPHEMERIS</em>&nbsp;</td><td>
<p>Provide ephemeris assistance </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a771ea75bb55563f40ba2f3b07634020ea125a7ffb6fc05d6a211d8372dee07020"></a><!-- doxytag: member="RXN_CL_ASSIST_LOC" ref="a771ea75bb55563f40ba2f3b07634020ea125a7ffb6fc05d6a211d8372dee07020" args="" -->RXN_CL_ASSIST_LOC</em>&nbsp;</td><td>
<p>Provide location assistance </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a771ea75bb55563f40ba2f3b07634020ea2ccb6081b748794bbb3c37f8a4bb6fbe"></a><!-- doxytag: member="RXN_CL_ASSIST_TIME" ref="a771ea75bb55563f40ba2f3b07634020ea2ccb6081b748794bbb3c37f8a4bb6fbe" args="" -->RXN_CL_ASSIST_TIME</em>&nbsp;</td><td>
<p>Provide time assistance </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a771ea75bb55563f40ba2f3b07634020eaa2ac10911737931dc7eb6b823bdf9318"></a><!-- doxytag: member="RXN_CL_RESTART_END" ref="a771ea75bb55563f40ba2f3b07634020eaa2ac10911737931dc7eb6b823bdf9318" args="" -->RXN_CL_RESTART_END</em>&nbsp;</td><td>
<p>Restart boundary. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a4ebd1cdaa2b228aaa4914114f6a2d84d"></a><!-- doxytag: member="RXN_CL.h::RXN_CL_ClkOffsetChange_CB" ref="a4ebd1cdaa2b228aaa4914114f6a2d84d" args="(S32 newOffset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RXN_CL_ClkOffsetChange_CB </td>
          <td>(</td>
          <td class="paramtype">S32&nbsp;</td>
          <td class="paramname"> <em>newOffset</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Notifies of an offset change (current GPS time from the receiver - GPS time calculated from RTC). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newOffset</em>&nbsp;</td><td>[OUT] New offset value.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Description</b><br/>
 This callback notifies CL consumers of a change in the offset between the GPS time obtained from a receiver after a fix and the GPS time calculated using the system RTC. This offset will only be non-zero when the RTC is inaccurate due to drift or improper user setting.</p>
<p><b>Notes:</b> </p>
<ul>
<li>
Access to GPS time may not be supported on all chipsets. When access to the GPS time is not supported on a chipset, this callback will never be called. </li>
<li>
To request the current offset value within the CL, RXN_CL_GetClkOffset can be used. </li>
</ul>

</div>
</div>
<a class="anchor" id="afbc36ae58a898507d225fb4df226997d"></a><!-- doxytag: member="RXN_CL.h::RXN_CL_FullToRXN" ref="afbc36ae58a898507d225fb4df226997d" args="(RXN_FullEph_t *pFull, RXN_ephem_t *pRXN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RXN_CL_FullToRXN </td>
          <td>(</td>
          <td class="paramtype">RXN_FullEph_t *&nbsp;</td>
          <td class="paramname"> <em>pFull</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RXN_ephem_t *&nbsp;</td>
          <td class="paramname"> <em>pRXN</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert ephemeris data (full ephemeris to RXN ephemeris). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pFull</em>&nbsp;</td><td>[IN] Pointer to a source RXN_FullEph_t struct. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pRXN</em>&nbsp;</td><td>[OUT] Pointer to a destination RXN_ephem_t struct.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Description</b><br/>
 Convert ephemeris data from a comprehensive struct that supports elements that are found within RINEX data files (RXN_FullEph_t) to a more compact struct that is expected by Rx Networks libraries as standard (RXN_ephem_t).</p>
<p><b>See Also</b><br/>
 <a class="el" href="RXN__CL_8h.html#aadbe9bfd94f7536dbcd53c4db691feaa" title="Convert ephemeris data (RXN ephemeris to full ephemeris).">RXN_CL_RXNToFull()</a></p>
<p><b>Example Usage</b> </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Setup an array for full ephemeris data storage.</span>
 RXN_FullEph_t FullArr[RXN_CONSTANT_NUM_PRNS];

 <span class="comment">// Setup an array for RXN ephemeris data storage.</span>
 RXN_ephem_t RXNArr[RXN_CONSTANT_NUM_PRNS];

 <span class="comment">// ToDo: Populate FullArr from a source such as RINEX (for example).</span>

 <span class="comment">// Convert FullArr to RXNArr.</span>
 <a class="code" href="RXN__CL_8h.html#afbc36ae58a898507d225fb4df226997d" title="Convert ephemeris data (full ephemeris to RXN ephemeris).">RXN_CL_FullToRXN</a>(FullArr, RXNArr);
</pre></div> 
</div>
</div>
<a class="anchor" id="a90d6683386a410106ad5b46823c55e3f"></a><!-- doxytag: member="RXN_CL.h::RXN_CL_Get_API_Version" ref="a90d6683386a410106ad5b46823c55e3f" args="(char version[RXN_CONSTANT_VERSION_STRING_LENGTH])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U16 RXN_CL_Get_API_Version </td>
          <td>(</td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>version</em>[RXN_CONSTANT_VERSION_STRING_LENGTH]</td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the Chipset Lib (CL) API version. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>version</em>&nbsp;</td><td>[OUT] A memory location to be filled with the current API version. This is a null terminated string and is at most RXN_CONSTANT_VERSION_STRING_LENGTH (50) characters long.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RXN_SUCCESS If the version is returned successfully (always).</dd></dl>
<p><b>Description</b><br/>
 This function returns the version of the CL. The version number will be incremented as new features, enhancements, and bug fixes are added to the CL. The version number is an important identification when reporting and troubleshooting issues. Rx Networks version numbers are broken down within Integration User's Manuals.</p>
<p><b>Example Usage</b> </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Declare a string to hold version info.</span>
 <span class="keywordtype">char</span> version[RXN_CONSTANT_VERSION_STRING_LENGTH];
 
 <span class="comment">// Retrieve and output version information.</span>
 <a class="code" href="RXN__CL_8h.html#a90d6683386a410106ad5b46823c55e3f" title="Retrieve the Chipset Lib (CL) API version.">RXN_CL_Get_API_Version</a>(version);
 printf(<span class="stringliteral">&quot;RXN_CL_Get_API_Version(): %s\n&quot;</span>, version);
</pre></div><p><b>Output</b><br/>
 <a class="el" href="RXN__CL_8h.html#a90d6683386a410106ad5b46823c55e3f" title="Retrieve the Chipset Lib (CL) API version.">RXN_CL_Get_API_Version()</a>: 1.2.0 </p>

</div>
</div>
<a class="anchor" id="aa817c8bcd4e54fdbf8dc0f60922b8251"></a><!-- doxytag: member="RXN_CL.h::RXN_CL_Get_Chipset" ref="aa817c8bcd4e54fdbf8dc0f60922b8251" args="(char chipset[RXN_CL_CHIP_MAX_STR_LEN])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U16 RXN_CL_Get_Chipset </td>
          <td>(</td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>chipset</em>[RXN_CL_CHIP_MAX_STR_LEN]</td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve a chipset descriptor from the library (for which it has been compiled). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chipset</em>&nbsp;</td><td>[OUT] A memory location to be filled with a list of supported chipsets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RXN_SUCCESS If the list is returned successfully (always).</dd></dl>
<p><b>Example Usage</b> </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Declare a string to hold a chipset label.</span>
 <span class="keywordtype">char</span> chipset[<a class="code" href="RXN__CL__Constants_8h.html#a6842ca0314cc2c6fce83d351c0bfdd76" title="Defines a max length for a chipset string. Long length required by RxN Eng for DLL...">RXN_CL_CHIP_MAX_STR_LEN</a>];
 
 <span class="comment">// Retrieve and output the chipset label.</span>
 <a class="code" href="RXN__CL_8h.html#aa817c8bcd4e54fdbf8dc0f60922b8251" title="Retrieve a chipset descriptor from the library (for which it has been compiled).">RXN_CL_Get_Chipset</a>(chipset);
 printf(<span class="stringliteral">&quot;RXN_CL_Get_Chipset(): %s\n&quot;</span>, chipset);
</pre></div><p><b>Output</b><br/>
 <a class="el" href="RXN__CL_8h.html#aa817c8bcd4e54fdbf8dc0f60922b8251" title="Retrieve a chipset descriptor from the library (for which it has been compiled).">RXN_CL_Get_Chipset()</a>: "u-blox 5.0" </p>

</div>
</div>
<a class="anchor" id="a059221097d784a0626fd7a5d4e002684"></a><!-- doxytag: member="RXN_CL.h::RXN_CL_Get_Chipset_Support_Version" ref="a059221097d784a0626fd7a5d4e002684" args="(U16 handle, char version[RXN_CONSTANT_VERSION_STRING_LENGTH])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U16 RXN_CL_Get_Chipset_Support_Version </td>
          <td>(</td>
          <td class="paramtype">U16&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>version</em>[RXN_CONSTANT_VERSION_STRING_LENGTH]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve version info from the chipset. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>[IN] A handle that identifies a CL instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>version</em>&nbsp;</td><td>[OUT] Buffer to copy a chipset version string into.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RXN_SUCCESS if version data is retrieved successfully. </dd>
<dd>
RXN_CL_INSTANCE_NOT_FOUND_ERR if the handle provided does not support an open CL instance. </dd>
<dd>
RXN_CL_NO_CHIPSET_SUPPORT_ERR if the chipset selected within <a class="el" href="RXN__CL_8h.html#a92e14faace538133eae58594f2aa4907" title="Initialize the CL library for use with a specific chipset and version of chipset...">RXN_CL_Initialize()</a> does not support this function. </dd>
<dd>
RXN_CL_OPEN_OR_CLOSE_ERR if a port supporting access to the chipset has not been opened. </dd>
<dd>
RXN_CL_CHIPSET_READ_ERR if the version info cannot be read for the chipset. </dd>
<dd>
RXN_CL_CHIPSET_READ_TIMEOUT if a timeout occurred while waiting for a chipset msg. </dd>
<dd>
RXN_CL_MSG_NACK_ERROR if the request for version data is nacked.</dd></dl>
<p><b>Notes:</b> </p>
<ul>
<li>
The version string returned is intended to show firmware version for chipsets with a protocol interface or lib version for hosted chipsets. </li>
<li>
If the chipset does not support version access, "N/A" (or similar) will be provided as a version string. </li>
<li>
The string will be terminated by "\0". </li>
<li>
String allocated length (including support for "\0") must be RXN_CONSTANT_VERSION_STRING_LENGTH. </li>
</ul>
<p><b>Example Usage</b> </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// ToDo: Initialize a CL instance for use. See RXN_CL_Initialize() example usage.</span>
 <span class="comment">// Initialization will yield a &quot;handle&quot; for use within the</span>
 <span class="comment">// RXN_CL_Get_Chipset_Support_Version() call below.</span>

 <span class="comment">// Declare a string to hold version info.</span>
 <span class="keywordtype">char</span> version[RXN_CONSTANT_VERSION_STRING_LENGTH];
 
 <span class="comment">// Retrieve version information.</span>
 <span class="keywordflow">if</span>(<a class="code" href="RXN__CL_8h.html#a059221097d784a0626fd7a5d4e002684" title="Retrieve version info from the chipset.">RXN_CL_Get_Chipset_Support_Version</a>(handle, version) != RXN_SUCCESS)
 {
    <span class="comment">// ToDo: Handle error.</span>
 }

 <span class="comment">// Print out the version.</span>
 printf(<span class="stringliteral">&quot;RXN_CL_Get_Chipset_Support_Version(): %s\n&quot;</span>, version);
</pre></div><p><b>Output</b><br/>
 <a class="el" href="RXN__CL_8h.html#a059221097d784a0626fd7a5d4e002684" title="Retrieve version info from the chipset.">RXN_CL_Get_Chipset_Support_Version()</a>: Version. Major: 1, Minor: 2 </p>

</div>
</div>
<a class="anchor" id="a24b70895edb449b3ca615a22cb48fceb"></a><!-- doxytag: member="RXN_CL.h::RXN_CL_GetAssistance" ref="a24b70895edb449b3ca615a22cb48fceb" args="(U08 assistTypeBitMask, U32 gpsPrnBitMask, U32 gloSlotBitMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RXN_CL_GetAssistance </td>
          <td>(</td>
          <td class="paramtype">U08&nbsp;</td>
          <td class="paramname"> <em>assistTypeBitMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&nbsp;</td>
          <td class="paramname"> <em>gpsPrnBitMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&nbsp;</td>
          <td class="paramname"> <em>gloSlotBitMask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get assistance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>assistTypeBitMask</em>&nbsp;</td><td>[IN] a bitmask of assistance types. Please refert to RXN_MSL_Assistance_Type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpsPrnBitMask</em>&nbsp;</td><td>[IN] gpsPrnBitMask is a bitmask where bit0 is equal to PRN1, bit1 is PRN2 ... </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gloSlotBitMask</em>&nbsp;</td><td>[IN] gloSlotBitMask is a bitmask where bit0 is equal to Slot1, bit1 is Slot2 ...</td></tr>
  </table>
  </dd>
</dl>
<p><b>Description</b><br/>
 Called by the CL to notify consumers that an assistance is required. This function is defined by the CL and must be implemented by CL consumers.</p>
<p><b>Notes:</b> </p>
<ul>
<li>
Regardless of whether this function is used, CL consumers must provide an implementation to avoid linkage errors. "Stubbing Out" the implementation will be sufficient to avoid linkage errors. </li>
</ul>
<p><b>Example Usage</b> </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Example stub implementation: RXN_CL_GetAssistance(U08 assistTypeBitMask, U32 gpsPrnBitMask, U32 gloSlotBitMask) {return;}</span>

 <span class="comment">// Implement the function.</span>
 <a class="code" href="RXN__CL_8h.html#a24b70895edb449b3ca615a22cb48fceb" title="Get assistance.">RXN_CL_GetAssistance</a>(U08 assistTypeBitMask, U32 gpsPrnBitMask, U32 gloSlotBitMask)
 {
    <span class="comment">// ToDo: Inject time, position, EE or BCE .</span>
  
    <span class="keywordflow">return</span>;
 }
</pre></div> 
</div>
</div>
<a class="anchor" id="accbe073860c5725df7fb63fce99fe9a0"></a><!-- doxytag: member="RXN_CL.h::RXN_CL_GetClkOffset" ref="accbe073860c5725df7fb63fce99fe9a0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">S32 RXN_CL_GetClkOffset </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the offset between RTC time and GPS time maintained within the CL. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current offset between GPS time and the system RTC time. If the offset has not been set (i.e. as a result of measuring the offset after getting a position fix or because the offset is not maintained for the current chipset) a value of RXN_CL_INVALID_CLK_OFFSET will be returned.</dd></dl>
<p><b>Description</b><br/>
 Implementations of the CL some chipsets, will maintain an offset between the system RTC value and the current GPS time. This offset can be used by CL consumers and added to the RTC time to get an accurate time value (even when the RTC is inaccurate due to drift or an erroneous user setting).</p>
<p><b>Notes:</b> </p>
<ul>
<li>
Typically CL consumers will get the current offset after CL initialization and whenever required. Consumers will be notified of offset changes via the <a class="el" href="RXN__CL_8h.html#a4ebd1cdaa2b228aaa4914114f6a2d84d" title="Notifies of an offset change (current GPS time from the receiver - GPS time calculated...">RXN_CL_ClkOffsetChange_CB()</a> function. This callback will support efficient notification to CL consumers of an offset change so that consumers need not poll the CL to determine if any offset change has occured. </li>
</ul>

</div>
</div>
<a class="anchor" id="ad2ae745ab295c1a07a21b9898a760784"></a><!-- doxytag: member="RXN_CL.h::RXN_CL_GetFixData" ref="ad2ae745ab295c1a07a21b9898a760784" args="(U16 handle, RXN_CL_FixData_t *pFixData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U16 RXN_CL_GetFixData </td>
          <td>(</td>
          <td class="paramtype">U16&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRXN__CL__FixData__t.html">RXN_CL_FixData_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pFixData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get fix data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>[IN] A handle that identifies a CL instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pFixData</em>&nbsp;</td><td>[OUT] Pointer to a <a class="el" href="structRXN__CL__FixData__t.html" title="Struct describing fix data.">RXN_CL_FixData_t</a> struct that will be populated with fix data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RXN_SUCCESS if fix data is read successfully. </dd>
<dd>
RXN_CL_INSTANCE_NOT_FOUND_ERR if the handle provided does not support an open CL instance. </dd>
<dd>
RXN_CL_NO_CHIPSET_SUPPORT_ERR if the chipset selected within <a class="el" href="RXN__CL_8h.html#a92e14faace538133eae58594f2aa4907" title="Initialize the CL library for use with a specific chipset and version of chipset...">RXN_CL_Initialize()</a> does not support this function. </dd>
<dd>
RXN_CL_OPEN_OR_CLOSE_ERR if a port supporting access to the chipset has not been opened. </dd>
<dd>
RXN_CL_CHIPSET_WRITE_ERR if a request msg could not be sent to the chipset. </dd>
<dd>
RXN_CL_CHIPSET_READ_ERR if a response msg could not be read from the chipset. </dd>
<dd>
RXN_CL_CHIPSET_READ_TIMEOUT if a timeout occurred while waiting for a chipset msg. </dd>
<dd>
RXN_CL_MSG_PARSE_ERROR if a response msg could not be parsed properly (i.e. msg format error). </dd>
<dd>
RXN_CL_MSG_NACK_ERROR if a fix data request is nacked.</dd></dl>
<p><b>Description</b><br/>
 Get fix data from a connected chipset. Fix data will include a fix status flag.</p>
<p><b>Notes:</b> </p>
<ul>
<li>
<a class="el" href="structRXN__CL__FixData__t.html" title="Struct describing fix data.">RXN_CL_FixData_t</a> supports both ECEF and LLA data elements. Both LLA and ECEF data elements will be set with location data regardless of the location data format supported by the chipset (i.e. if the chipset supports LLA, ECEF will be obtained by converting LLA data received from the chipset and visa-versa). This conversion is supported by internal CL utility functions (not exposed to CL consumers). </li>
</ul>
<p><b>Example Usage</b> </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// ToDo: Initialize a CL instance for use. See RXN_CL_Initialize() example usage.</span>
 <span class="comment">// Initialization will yield a &quot;handle&quot; for use within the RXN_CL_Restart() call below.</span>

 <span class="comment">// Setup a struct to store fix data.</span>
 <a class="code" href="structRXN__CL__FixData__t.html" title="Struct describing fix data.">RXN_CL_FixData_t</a> FixData;

 <span class="comment">// Read fix data.</span>
 <span class="keywordflow">if</span>(<a class="code" href="RXN__CL_8h.html#ad2ae745ab295c1a07a21b9898a760784" title="Get fix data.">RXN_CL_GetFixData</a>(handle, &amp;FixData) != RXN_SUCCESS)
 {
    <span class="comment">// ToDo: Handle error.</span>
 }

 <span class="comment">// ToDo: Do something meaningful with FixData.</span>
</pre></div> 
</div>
</div>
<a class="anchor" id="acaefe7d06443dfb0337f97521805d4db"></a><!-- doxytag: member="RXN_CL.h::RXN_CL_GetGPSMeasSet" ref="acaefe7d06443dfb0337f97521805d4db" args="(RXN_GPSMsrSetList_t *MeasSetElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U16 RXN_CL_GetGPSMeasSet </td>
          <td>(</td>
          <td class="paramtype">RXN_GPSMsrSetList_t *&nbsp;</td>
          <td class="paramname"> <em>MeasSetElements</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets GPS measurement sets including pseudo range data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>MeasSetElements</em>&nbsp;</td><td>[OUT] Measurement data sets including GPS measurement data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RXN_SUCCESS if data sets could be read successfully. </dd>
<dd>
RXN_FAIL if an error occurs when retrieving data sets.</dd></dl>
<p><b>Description</b><br/>
 This function retrieves GPS measurement sets from the receiver. These sets can be used within TRKR to get position data.</p>
<p><b>Notes:</b> </p>
<ul>
<li>
Additional return values to be determined upon implementation of the function. </li>
</ul>

</div>
</div>
<a class="anchor" id="a5557b6480519e4eb9de97f6587fbe017"></a><!-- doxytag: member="RXN_CL.h::RXN_CL_GetGPSRcvrTime" ref="a5557b6480519e4eb9de97f6587fbe017" args="(U16 handle, U16 *pRcvrWeekNum, U32 *pRcvrTOW)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U16 RXN_CL_GetGPSRcvrTime </td>
          <td>(</td>
          <td class="paramtype">U16&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U16 *&nbsp;</td>
          <td class="paramname"> <em>pRcvrWeekNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32 *&nbsp;</td>
          <td class="paramname"> <em>pRcvrTOW</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the current GPS time from the reciever (after the reciver fixes). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>[IN] A handle that identifies a CL instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pRcvrWeekNum</em>&nbsp;</td><td>[OUT] Pointer to the current GPS week number (since GPS start in 1970). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pRcvrTOW</em>&nbsp;</td><td>[OUT] Pointer to the current GPS time of week.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RXN_SUCCESS if fix data is read successfully. </dd>
<dd>
RXN_CL_DATA_UNAVAILABLE if the data is unavailable within the chipset at present. </dd>
<dd>
RXN_CL_INSTANCE_NOT_FOUND_ERR if the handle provided does not support an open CL instance. </dd>
<dd>
RXN_CL_NO_CHIPSET_SUPPORT_ERR if the chipset selected within <a class="el" href="RXN__CL_8h.html#a92e14faace538133eae58594f2aa4907" title="Initialize the CL library for use with a specific chipset and version of chipset...">RXN_CL_Initialize()</a> does not support this function. </dd>
<dd>
RXN_CL_OPEN_OR_CLOSE_ERR if a port supporting access to the chipset has not been opened. </dd>
<dd>
RXN_CL_CHIPSET_WRITE_ERR if a request msg could not be sent to the chipset. </dd>
<dd>
RXN_CL_CHIPSET_READ_ERR if a response msg could not be read from the chipset. </dd>
<dd>
RXN_CL_CHIPSET_READ_TIMEOUT if a timeout occurred while waiting for a chipset msg. </dd>
<dd>
RXN_CL_MSG_PARSE_ERROR if a response msg could not be parsed properly (i.e. msg format error). </dd>
<dd>
RXN_CL_MSG_NACK_ERROR if a fix data request is nacked.</dd></dl>
<p><b>Description</b><br/>
 Get the current GPS time from a connected chipset.</p>
<p><b>Notes:</b> </p>
<ul>
<li>
Access to GPS time may not be supported on all chipsets. When access to the GPS time is not supported on a chipset, it will return RXN_CL_NO_CHIPSET_SUPPORT_ERR. </li>
<li>
Before any chipset can return a GPS time, it must have a position fix. If this function is called before a position fix is completed and GPS reciever time is still unavailable, RXN_CL_DATA_UNAVAILABLE will be returned. </li>
</ul>
<p><b>Example Usage</b> </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// ToDo: Initialize a CL instance for use. See RXN_CL_Initialize() example usage.</span>
 <span class="comment">// Initialization will yield a &quot;handle&quot; for use within the RXN_CL_Restart() call below.</span>

 <span class="comment">// Setup a var to store reciever GPS .</span>
 U32 RcvrTOW;
 U16 RcvrWeekNum;

 <span class="comment">// Read the GPS time.</span>
 <span class="keywordflow">if</span>(<a class="code" href="RXN__CL_8h.html#a5557b6480519e4eb9de97f6587fbe017" title="Get the current GPS time from the reciever (after the reciver fixes).">RXN_CL_GetGPSRcvrTime</a>(handle, &amp;RcvrWeekNum, &amp;RcvrTOW) != RXN_SUCCESS)
 {
    <span class="comment">// ToDo: Handle error. If the error is RXN_CL_DATA_UNAVAILABLE try this call</span>
    <span class="comment">// later after a fix has been obtained.</span>
 }

 <span class="comment">// ToDo: Do something meaningful with RcvrGPSTime.</span>
</pre></div> 
</div>
</div>
<a class="anchor" id="a92e14faace538133eae58594f2aa4907"></a><!-- doxytag: member="RXN_CL.h::RXN_CL_Initialize" ref="a92e14faace538133eae58594f2aa4907" args="(U16 chipsetVer, char config[RXN_CL_CONFIG_MAX_STR_LEN], U16 *phandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U16 RXN_CL_Initialize </td>
          <td>(</td>
          <td class="paramtype">U16&nbsp;</td>
          <td class="paramname"> <em>chipsetVer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>config</em>[RXN_CL_CONFIG_MAX_STR_LEN], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U16 *&nbsp;</td>
          <td class="paramname"> <em>phandle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize the CL library for use with a specific chipset and version of chipset support. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chipsetVer</em>&nbsp;</td><td>[IN] Specifies a chipset version. CL implementations may be different for different versions of chipset firmware (for example). The chipset version number can be checked within CL implementation code to support different CL functionality for different chipset versions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>config</em>&nbsp;</td><td>[IN] Specifies the port to open during chipset initialization as well as any other config parameters. The format of the config string is chipset specific. Some chipsets (typically those supported by a host library or protocol interface) are initialized with a com port string and baudrate. Note that a debug log severity max level and debug zone mask are also stipulated. See details below. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phandle</em>&nbsp;</td><td>[OUT] The pointer to a handle that identifies a CL instance for subsequent CL use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RXN_SUCCESS if the CL is initialized successfully. </dd>
<dd>
RXN_CL_NO_CHIPSET_SUPPORT_ERR if the compile of the CL does not include support for the requested chipset. </dd>
<dd>
RXN_CL_CHIPSET_INIT_ERR if the chipset could not be initiated properly. Consult the CL log for more info as this error is chipset specific. </dd>
<dd>
RXN_CL_TOO_MANY_INSTANCES_ERR if too many instances of the CL are currently initialized. </dd>
<dd>
RXN_CL_CONFIG_FORMAT_ERR if the config string is malformed (e.g. does not include '|' if required), </dd>
<dd>
RXN_CL_OPEN_OR_CLOSE_ERR if the interface could not be opened (i.e. file or port open error). </dd>
<dd>
RXN_CL_PORT_SETUP_ERR if a com port could not be setup properly.</dd></dl>
<p><b>Description</b><br/>
 Initialize the CL library before using it. This will setup a CL instance (with associate handle). Instances are required to support clients that may have to utilize multiple copies of the CL at the same time.<br/>
 Specify a debug log max severity threshold to determine which CL log entries are processed. CL log severities defines are: </p>
<ul>
<li>
RXN_LOG_SEV_FATAL (0) - Log entry describing a fatal issue (CL will crash). </li>
<li>
RXN_LOG_SEV_ERROR (1) - Log entry describing an error. </li>
<li>
RXN_LOG_SEV_WARNING (2) - Log entry describing a warning. </li>
<li>
RXN_LOG_SEV_INFO (3) - Log entry includes general information. </li>
<li>
RXN_LOG_SEV_TRACE (4) - Log entry includes trace data that can be used for troubleshooting. </li>
</ul>
<p>When a severity threshold is set, all logs with severity matching, or more serious than this threshold will be processed. The default threshold of RXN_LOG_SEV_ERROR will be used when no threshold is specified (i.e. logs entries of severity RXN_LOG_SEV_ERROR and RXN_LOG_SEV_FATAL will be processed). To specify a severity threshold use "S:n" or "s:n" as the second last config parameter where n is the threshold value (i.e. "...|S:4|..." to specify RXN_LOG_SEV_TRACE threshold).<br/>
 Specify a debug zone mask to stipulate which debug zone log entries are processed. CL log debug zone defines are: </p>
<ul>
<li>
RXN_LOG_ZONE01 (1 - 0x0001) - Misc functionality (catch all when no other zones apply). </li>
<li>
RXN_LOG_ZONE02 (2 - 0x0002) - Third party log entries. </li>
<li>
RXN_LOG_ZONE03 (4 - 0x0004) - Init/Shutdown functionality. </li>
<li>
RXN_LOG_ZONE04 (8 - 0x0008) - Serial and socket I/O and other I/O functionality. </li>
<li>
RXN_LOG_ZONE05 (16 - 0x0010) - File I/O functionality. </li>
<li>
RXN_LOG_ZONE06 (32 - 0x0020) - Security functionality. </li>
<li>
RXN_LOG_ZONE07 - RXN_LOG_ZONE16 - Unused at present. </li>
</ul>
<p>When a debug zone mask is set, this mask will be used to filter out which zone log entries are processed. E.g. debug zone mask of 0x0003 will only support log entries with specified zones RXN_LOG_ZONE01 and RXN_LOG_ZONE02. A default zone mask of 0xFFFF will be used when no mask is specified (supports logging all entries regardless of their specified zone). To specify a zone mask use "Z:n", "Z:0xn", "z:n" or "z:0xn" as the last config parameter where n is the zone mask (i.e. "...|Z:0x000F").</p>
<p><b>See Also</b><br/>
 <a class="el" href="RXN__CL_8h.html#af0c5d6d1b7b92d394c3287b97f38f5f9" title="UnInitialize a CL library instance.">RXN_CL_Uninitialize()</a></p>
<p><b>Example Usage</b> </p>
<div class="fragment"><pre class="fragment"> U16 Result = RXN_FAIL;
 <span class="keywordtype">char</span> UBLOXConfig[<a class="code" href="RXN__CL__Constants_8h.html#adfed84fad98eac86ab7e3871ff038654" title="Defines a max length for a string describing the port or file path to open or other...">RXN_CL_CONFIG_MAX_STR_LEN</a>];
 U16 CLHandle = 0;

 <span class="comment">// Initialize logging first so that any problems that occur during subsequent CL</span>
 <span class="comment">// calls will be logged for troubleshooting.</span>
 Result = <a class="code" href="RXN__CL_8h.html#a11f29e760166343c13785b36451689a0" title="Initialize a log for CL library use.">RXN_CL_Log_Init</a>(<span class="stringliteral">&quot;./CL_Log.txt&quot;</span>);

 <span class="comment">// Handle errors.</span>
 <span class="keywordflow">if</span>(Result != RXN_SUCCESS)
 {
    <span class="comment">// ToDo: Notify the user that a log will not be supported.</span>
 }

 <span class="comment">// Setup a config string to support a USB Virtual Com port on COM3 at 115200 kBps</span>
 <span class="comment">// with severity level 1 logging (Fatal and Error log entries only) and debug zone</span>
 <span class="comment">// mask of 0xFFFF (permits logging for all zones).</span>
 sprintf(UBLOXConfig, <span class="stringliteral">&quot;P:\\\\.\\COM3|B:115200|S:1|Z:0xFFFF&quot;</span>);

 <span class="comment">// Initialize the CL to support a u-blox chipset with version 1.00 firmware.</span>
 Result = <a class="code" href="RXN__CL_8h.html#a92e14faace538133eae58594f2aa4907" title="Initialize the CL library for use with a specific chipset and version of chipset...">RXN_CL_Initialize</a>(100, UBLOXConfig, &amp;CLHandle);

 <span class="comment">// Handle errors.</span>
 <span class="keywordflow">if</span>(Result != RXN_SUCCESS)
 {
    <span class="comment">// ToDo: Handle a CL initialization error. May have to terminate function.</span>
 }

 <span class="comment">// ToDo; Call other functions using this instance of the CL by utilizing CLHandle.</span>

 <span class="comment">// Shutdown the CL instance.</span>
 Result = <a class="code" href="RXN__CL_8h.html#af0c5d6d1b7b92d394c3287b97f38f5f9" title="UnInitialize a CL library instance.">RXN_CL_Uninitialize</a>(CLHandle);

 <span class="comment">// Handle errors.</span>
 <span class="keywordflow">if</span>(Result != RXN_SUCCESS)
 {
    <span class="comment">// ToDo: Handle a CL un-initialization error.</span>
 }
 
 <span class="comment">// Shutdown logging. Always shutdown logging last to ensure that any CL</span>
 issues that preceed <span class="keyword">this</span> call are logged.
 <a class="code" href="RXN__CL_8h.html#aa29c0f302ecbd4cf395cf08a1159c05a" title="Un-Initialize a log that has been opened for CL library use.">RXN_CL_Log_UnInit</a>();
</pre></div> 
</div>
</div>
<a class="anchor" id="a11f29e760166343c13785b36451689a0"></a><!-- doxytag: member="RXN_CL.h::RXN_CL_Log_Init" ref="a11f29e760166343c13785b36451689a0" args="(const char logFile[RXN_CL_MAX_LOG_PATH])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U16 RXN_CL_Log_Init </td>
          <td>(</td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>logFile</em>[RXN_CL_MAX_LOG_PATH]</td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize a log for CL library use. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>logFile</em>&nbsp;</td><td>[IN] Explicit or relative path to the log file. Must specify a full path including file name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RXN_SUCCESS if the log is initialized successfully. </dd>
<dd>
RXN_CL_TOO_MANY_INSTANCES_ERR - if an log has already been opened. </dd>
<dd>
RXN_CL_OPEN_OR_CLOSE_ERR - if a log file cannot be opened.</dd></dl>
<p><b>Description</b><br/>
 Open a log file that can be used by library implementation code directly, or by an third party library that is being hosted by the CL (i.e. for hosted systems). If the log file exists, it will be replaced. If the log file does not exist, it will be created. Note that all instances of the CL will share a common log.</p>
<p><b>See Also</b><br/>
 <a class="el" href="RXN__CL_8h.html#aa29c0f302ecbd4cf395cf08a1159c05a" title="Un-Initialize a log that has been opened for CL library use.">RXN_CL_Log_UnInit()</a></p>
<p><b>Example Usage</b> </p>
<div class="fragment"><pre class="fragment"> See the example code provided <span class="keywordflow">for</span> <a class="code" href="RXN__CL_8h.html#a92e14faace538133eae58594f2aa4907" title="Initialize the CL library for use with a specific chipset and version of chipset...">RXN_CL_Initialize</a>().
</pre></div> 
</div>
</div>
<a class="anchor" id="aa29c0f302ecbd4cf395cf08a1159c05a"></a><!-- doxytag: member="RXN_CL.h::RXN_CL_Log_UnInit" ref="aa29c0f302ecbd4cf395cf08a1159c05a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RXN_CL_Log_UnInit </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Un-Initialize a log that has been opened for CL library use. </p>
<p><b>Description</b><br/>
 Close a previously opened log file (if opened).</p>
<p><b>See Also</b><br/>
 <a class="el" href="RXN__CL_8h.html#a11f29e760166343c13785b36451689a0" title="Initialize a log for CL library use.">RXN_CL_Log_Init()</a></p>
<p><b>Example Usage</b> </p>
<div class="fragment"><pre class="fragment"> See the example code provided <span class="keywordflow">for</span> <a class="code" href="RXN__CL_8h.html#a92e14faace538133eae58594f2aa4907" title="Initialize the CL library for use with a specific chipset and version of chipset...">RXN_CL_Initialize</a>().
</pre></div> 
</div>
</div>
<a class="anchor" id="ae417df1e3e41fcb71ade1b34d2e82058"></a><!-- doxytag: member="RXN_CL.h::RXN_CL_ReadEphemeris" ref="ae417df1e3e41fcb71ade1b34d2e82058" args="(U16 handle, RXN_MSL_NavDataList_t *pNavDataList, RXN_constel_t constel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U16 RXN_CL_ReadEphemeris </td>
          <td>(</td>
          <td class="paramtype">U16&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RXN_MSL_NavDataList_t *&nbsp;</td>
          <td class="paramname"> <em>pNavDataList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RXN_constel_t&nbsp;</td>
          <td class="paramname"> <em>constel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read broadcast ephemeris data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>[IN] A handle that identifies a CL instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pNavDataList</em>&nbsp;</td><td>[OUT] A pointer to a RXN_MSL_NavDataList_t struct that will be populated with ephemeris data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>constel</em>&nbsp;</td><td>[IN] The constellation</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RXN_SUCCESS if ephemeris is read successfully. </dd>
<dd>
RXN_CL_INSTANCE_NOT_FOUND_ERR if the handle provided does not support an open CL instance. </dd>
<dd>
RXN_CL_NO_CHIPSET_SUPPORT_ERR if the chipset selected within <a class="el" href="RXN__CL_8h.html#a92e14faace538133eae58594f2aa4907" title="Initialize the CL library for use with a specific chipset and version of chipset...">RXN_CL_Initialize()</a> does not support this function. </dd>
<dd>
RXN_CL_OPEN_OR_CLOSE_ERR if a port supporting access to the chipset has not been opened. </dd>
<dd>
RXN_CL_CHIPSET_WRITE_ERR if a request msg could not be sent to the chipset. </dd>
<dd>
RXN_CL_CHIPSET_READ_ERR if a response msg could not be read from the chipset. </dd>
<dd>
RXN_CL_CHIPSET_READ_TIMEOUT if a timeout occurred while waiting for a chipset msg. </dd>
<dd>
RXN_CL_MSG_NACK_ERROR if a read request is nacked. </dd>
<dd>
RXN_CL_ALLOCATION_ERROR if the array size specified is invalid (&lt; 1 or &gt; 32).</dd></dl>
<p><b>Description</b><br/>
 Read an array of broadcast ephemeris (BCE) data structs through a previously initialized CL instance.</p>
<p><b>Notes:</b> </p>
<ul>
<li>
For any given PRN within PRNArr, the prn value will be set to "0" if ephemeris was not available for that PRN. </li>
<li>
To convert the PRNArr elements returned from RXN_FullEph_t to RXN_ephem_t as supported within Rx Networks GPStream products, utilize <a class="el" href="RXN__CL_8h.html#afbc36ae58a898507d225fb4df226997d" title="Convert ephemeris data (full ephemeris to RXN ephemeris).">RXN_CL_FullToRXN()</a>. </li>
<li>
Reading broadcast ephemeris from a chipset may take up to 32 function calls or protocol messages. For this reason, this function may not return for several seconds. </li>
</ul>
<p><b>See Also</b><br/>
 <a class="el" href="RXN__CL_8h.html#a8b09f50528981195bd1b115b7692b050" title="Write extended ephemeris data.">RXN_CL_WriteEphemeris()</a>, <a class="el" href="RXN__CL_8h.html#afbc36ae58a898507d225fb4df226997d" title="Convert ephemeris data (full ephemeris to RXN ephemeris).">RXN_CL_FullToRXN()</a></p>
<p><b>Example Usage</b> </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// ToDo: Initialize a CL instance for use. See RXN_CL_Initialize() example usage.</span>
 <span class="comment">// Initialization will yield a &quot;handle&quot; for use within the RXN_CL_ReadEphemeris() call below.</span>

 <span class="comment">// Setup an array for ephemeris data store.</span>
 RXN_FullEphem_u PRNEphArr[RXN_CONSTANT_NUM_PRNS];

 <span class="comment">// Read ephemeris into pNavDataList.</span>
 <span class="keywordflow">if</span>(<a class="code" href="RXN__CL_8h.html#ae417df1e3e41fcb71ade1b34d2e82058" title="Read broadcast ephemeris data.">RXN_CL_ReadEphemeris</a>(handle, pNavDataList, RXN_GPS_CONSTEL) != RXN_SUCCESS)
 {
    <span class="comment">// ToDo: Handle error.</span>
 }

 <span class="comment">// ToDo: Do something meaningful with pNavDataList such as set it within SAGPS.</span>
</pre></div> 
</div>
</div>
<a class="anchor" id="ade314c9e8cc5b198dfda90f4985efd1a"></a><!-- doxytag: member="RXN_CL.h::RXN_CL_Restart" ref="ade314c9e8cc5b198dfda90f4985efd1a" args="(U16 handle, RXN_CL_Restarts_t restartType, RXN_RefLocation_t *pRefLoc, RXN_RefTime_t *pRefTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U16 RXN_CL_Restart </td>
          <td>(</td>
          <td class="paramtype">U16&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="RXN__CL_8h.html#a771ea75bb55563f40ba2f3b07634020e">RXN_CL_Restarts_t</a>&nbsp;</td>
          <td class="paramname"> <em>restartType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RXN_RefLocation_t *&nbsp;</td>
          <td class="paramname"> <em>pRefLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RXN_RefTime_t *&nbsp;</td>
          <td class="paramname"> <em>pRefTime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Restart the chipset. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>[IN] A handle that identifies a CL instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>restartType</em>&nbsp;</td><td>[IN] A value (enumerated RXN_CL_Restarts_t) that identifies what type of restart to perform. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pRefLoc</em>&nbsp;</td><td>[IN] A pointer to a RXN_RefLocation_t struct that includes reference location data, or NULL (0) if ref location set not supported within reset msg or function or is not required. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pRefTime</em>&nbsp;</td><td>[IN] A pointer to a RXN_RefTime_t struct that includes reference time data, or NULL (0) if ref time set not supported within reset msg or function or is not required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RXN_SUCCESS if a restart is successful. </dd>
<dd>
RXN_CL_INSTANCE_NOT_FOUND_ERR if the handle provided does not support an open CL instance. </dd>
<dd>
RXN_CL_NO_CHIPSET_SUPPORT_ERR if the chipset selected within <a class="el" href="RXN__CL_8h.html#a92e14faace538133eae58594f2aa4907" title="Initialize the CL library for use with a specific chipset and version of chipset...">RXN_CL_Initialize()</a> does not support this function. </dd>
<dd>
RXN_CL_INVALID_RESTART_TYPE_ERR if an invalid restartType is specified (must be RXN_CL_Restarts_t enum member). </dd>
<dd>
RXN_CL_INVALID_REF_LOC_FORMAT_ERR if the pRefLoc format value is not either RXN_LOC_ECEF or RXN_LOC_LLA. </dd>
<dd>
RXN_CL_OPEN_OR_CLOSE_ERR if a port supporting access to the chipset has not been opened. </dd>
<dd>
RXN_CL_CHIPSET_WRITE_ERR if a request msg could not be sent to the chipset. </dd>
<dd>
RXN_CL_CHIPSET_READ_ERR if a response msg could not be read from the chipset. </dd>
<dd>
RXN_CL_CHIPSET_READ_TIMEOUT if a timeout occurred while waiting for a chipset msg. </dd>
<dd>
RXN_CL_MSG_NACK_ERROR if restart request is nacked.</dd></dl>
<p><b>Description</b><br/>
 Perform a cold, warm or hot restart. If a chipset supports setting reference location and time within the reset msg or function, include these structures. If not, use "0" for reference location and/or reference time pointers.</p>
<p><b>Notes:</b> </p>
<ul>
<li>
If a separate msg(s) or function call(s) is required to set reference location and/or time, this msg will be sent or function call made after the reset msg or function call. Use <a class="el" href="RXN__CL_8h.html#a72527b125130326a68f1bc1331309ef1" title="Set a reference location and/or time within the chipset.">RXN_CL_SetRefLocTime()</a> for this purpose. </li>
<li>
Integrators can elect to set pRefLoc and/or pRefTime to NULL to avoid setting either or both of these parameters within a chipset during restart. </li>
<li>
If a pRefLoc and/or pRefTime provided cannot be used by the chipset, these parameters may be ignored. Chipset behaviour may differ from chipset to chipset. For example, some chipsets may require that a reference location be provided if a reference time is processed as both may be included within a function to set reference data. </li>
</ul>
<p><b>See Also</b><br/>
 <a class="el" href="RXN__CL_8h.html#a72527b125130326a68f1bc1331309ef1" title="Set a reference location and/or time within the chipset.">RXN_CL_SetRefLocTime()</a></p>
<p><b>Example Usage</b> </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// ToDo: Initialize a CL instance for use. See RXN_CL_Initialize() example usage.</span>
 <span class="comment">// Initialization will yield a &quot;handle&quot; for use within the RXN_CL_Restart() call below.</span>
 
 <span class="comment">// Setup ref location data.</span>
 RXN_RefLocation_t RefLoc;
 memset((<span class="keywordtype">void</span>*) &amp;RefLoc, 0, <span class="keyword">sizeof</span>(RXN_RefLocation_t));
 RefLoc.format = RXN_LOC_LLA;
 RefLoc.LLA.Lat = 49.28381;       <span class="comment">// RXN Office</span>
 RefLoc.LLA.Lon = -123.10463;     <span class="comment">// RXN Office</span>
 RefLoc.LLA.Alt = 10.60308;       <span class="comment">// RXN Office</span>

 <span class="comment">// Setup ref time data.</span>
 RXN_RefTime_t RefTime;
 memset((<span class="keywordtype">void</span>*) &amp;RefTime, 0, <span class="keyword">sizeof</span>(RXN_RefTime_t));
 RefTime.weekNum = CL_GetGPSWeekNum();  <span class="comment">// CL_GetGPSWeekNum() is util fcn supported within the CL.</span>
 RefTime.TOWmSec = CL_GetGPSTOW();      <span class="comment">// CL_GetGPSTOW() is a util fcn supported within the CL.</span>
 RefTime.TOWnSec = 0;
 RefTime.TAccmSec = 0;
 RefTime.TAccnSec = 0;

 <span class="comment">// Perform a cold restart.</span>
 <span class="keywordflow">if</span>(<a class="code" href="RXN__CL_8h.html#ade314c9e8cc5b198dfda90f4985efd1a" title="Restart the chipset.">RXN_CL_Restart</a>(handle, <a class="code" href="RXN__CL_8h.html#a771ea75bb55563f40ba2f3b07634020ea2e7a06c5f1bb432ab2370184f6e7dbd9">RXN_CL_COLD_RESTART</a>, &amp;RefLoc, &amp;RefTime) != RXN_SUCCESS)
 {
    <span class="comment">// ToDo: Handle error.</span>
 }
</pre></div> 
</div>
</div>
<a class="anchor" id="aadbe9bfd94f7536dbcd53c4db691feaa"></a><!-- doxytag: member="RXN_CL.h::RXN_CL_RXNToFull" ref="aadbe9bfd94f7536dbcd53c4db691feaa" args="(RXN_ephem_t *pRXN, RXN_FullEph_t *pFull, U08 CAOrPOnL2, U16 iodc, U08 L2PData, S08 TGD, U08 AODO)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RXN_CL_RXNToFull </td>
          <td>(</td>
          <td class="paramtype">RXN_ephem_t *&nbsp;</td>
          <td class="paramname"> <em>pRXN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RXN_FullEph_t *&nbsp;</td>
          <td class="paramname"> <em>pFull</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U08&nbsp;</td>
          <td class="paramname"> <em>CAOrPOnL2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U16&nbsp;</td>
          <td class="paramname"> <em>iodc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U08&nbsp;</td>
          <td class="paramname"> <em>L2PData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S08&nbsp;</td>
          <td class="paramname"> <em>TGD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U08&nbsp;</td>
          <td class="paramname"> <em>AODO</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert ephemeris data (RXN ephemeris to full ephemeris). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pRXN</em>&nbsp;</td><td>[IN] Pointer to a source RXN_ephem_t struct. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pFull</em>&nbsp;</td><td>[OUT] Pointer to a destination RXN_FullEph_t struct. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CAOrPOnL2</em>&nbsp;</td><td>[IN] CA or P On L2 flag value to set within the struct pointed to by pFull. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iodc</em>&nbsp;</td><td>[IN] IODC value to set within the struct pointed to by pFull. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>L2PData</em>&nbsp;</td><td>[IN] L2 PData value to set within the struct pointed to by pFull. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TGD</em>&nbsp;</td><td>[IN] TGD value to set within the struct pointed to by pFull. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AODO</em>&nbsp;</td><td>[IN] AODO value to set within the struct pointed to by pFull.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Description</b><br/>
 Convert ephemeris data from the standard expected by Rx Networks libraries (RXN_ephem_t) to a more comprehensive structure that also supports elements that are found within RINEX data files and used by other Rx Networks libraries (RXN_FullEph_t).</p>
<p><b>See Also</b><br/>
 <a class="el" href="RXN__CL_8h.html#afbc36ae58a898507d225fb4df226997d" title="Convert ephemeris data (full ephemeris to RXN ephemeris).">RXN_CL_FullToRXN()</a></p>
<p><b>Example Usage</b> </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Setup an array for full ephemeris data storage.</span>
 RXN_FullEph_t FullArr[RXN_CONSTANT_NUM_PRNS];

 <span class="comment">// Setup an array for RXN ephemeris data storage.</span>
 RXN_ephem_t RXNArr[RXN_CONSTANT_NUM_PRNS];

 <span class="comment">// ToDo: Populate RXNArr using a GPStream product.</span>

 <span class="comment">// Convert RXNArr to FullArr. Use &quot;0&quot; for all values included within</span>
 <span class="comment">// RXN_FullEph_t that are not supported by RXN_ephem_t.</span>
 <span class="comment">// (e.g. CAOrPOnL2, iodc, etc).</span>
 <a class="code" href="RXN__CL_8h.html#aadbe9bfd94f7536dbcd53c4db691feaa" title="Convert ephemeris data (RXN ephemeris to full ephemeris).">RXN_CL_RXNToFull</a>(RXNArr, FullArr, 0, 0, 0, 0, 0);
</pre></div> 
</div>
</div>
<a class="anchor" id="a72527b125130326a68f1bc1331309ef1"></a><!-- doxytag: member="RXN_CL.h::RXN_CL_SetRefLocTime" ref="a72527b125130326a68f1bc1331309ef1" args="(U16 handle, RXN_RefLocation_t *pRefLoc, RXN_RefTime_t *pRefTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U16 RXN_CL_SetRefLocTime </td>
          <td>(</td>
          <td class="paramtype">U16&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RXN_RefLocation_t *&nbsp;</td>
          <td class="paramname"> <em>pRefLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RXN_RefTime_t *&nbsp;</td>
          <td class="paramname"> <em>pRefTime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a reference location and/or time within the chipset. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>[IN] A handle that identifies a CL instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pRefLoc</em>&nbsp;</td><td>[IN] A pointer to a RXN_RefLocation_t struct that includes reference location data, or NULL (0) if ref location set not supported within reset msg or function or is not required.. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pRefTime</em>&nbsp;</td><td>[IN] A pointer to a RXN_RefTime_t struct that includes reference time data, or NULL (0) if ref time set not supported within reset msg or function or is not required..</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RXN_SUCCESS if either ref location or time set is successful. </dd>
<dd>
RXN_CL_INSTANCE_NOT_FOUND_ERR if the handle provided does not support an open CL instance. </dd>
<dd>
RXN_CL_NO_CHIPSET_SUPPORT_ERR if the chipset selected within <a class="el" href="RXN__CL_8h.html#a92e14faace538133eae58594f2aa4907" title="Initialize the CL library for use with a specific chipset and version of chipset...">RXN_CL_Initialize()</a> does not support this function. </dd>
<dd>
RXN_CL_INVALID_REF_LOC_FORMAT_ERR if the pRefLoc format value is not either RXN_LOC_ECEF or RXN_LOC_LLA. </dd>
<dd>
RXN_CL_OPEN_OR_CLOSE_ERR if a port supporting access to the chipset has not been opened. </dd>
<dd>
RXN_CL_CHIPSET_WRITE_ERR if a request msg could not be sent to the chipset. </dd>
<dd>
RXN_CL_CHIPSET_READ_ERR if a response msg could not be read from the chipset. </dd>
<dd>
RXN_CL_CHIPSET_READ_TIMEOUT if a timeout occurred while waiting for a chipset msg. </dd>
<dd>
RXN_CL_MSG_NACK_ERROR if request to set init time and location is nacked.</dd></dl>
<p><b>Description</b><br/>
 Set reference location or time (or both). Only if a valid value pointer is provided will a value be set within the chipset. Typically, these values are written to chipsets after a restart occurs. On some chipsets, these values are set as a restart is performed. If the CL is used to initiate such a restart for such chipsets, the <a class="el" href="RXN__CL_8h.html#ade314c9e8cc5b198dfda90f4985efd1a" title="Restart the chipset.">RXN_CL_Restart()</a> can support reference location and time set. <a class="el" href="RXN__CL_8h.html#a72527b125130326a68f1bc1331309ef1" title="Set a reference location and/or time within the chipset.">RXN_CL_SetRefLocTime()</a> use is intended for integrations where applications will react to restarts and set reference location and time data as required.</p>
<p><b>Notes:</b> </p>
<ul>
<li>
Integrators can elect to set pRefLoc and/or pRefTime to NULL to avoid setting either of these parameters within a chipset. </li>
<li>
If a pRefLoc and/or pRefTime provided cannot be used by the chipset, these parameters may be ignored. </li>
</ul>
<p><b>See Also</b><br/>
 <a class="el" href="RXN__CL_8h.html#ade314c9e8cc5b198dfda90f4985efd1a" title="Restart the chipset.">RXN_CL_Restart()</a></p>
<p><b>Example Usage</b> </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// ToDo: Initialize a CL instance for use. See RXN_CL_Initialize() example usage.</span>
 <span class="comment">// Initialization will yield a &quot;handle&quot; for use within the RXN_CL_SetRefLocTime() call below.</span>
 
 <span class="comment">// Setup ref location data.</span>
 RXN_RefLocation_t RefLoc;
 memset((<span class="keywordtype">void</span>*) &amp;RefLoc, 0, <span class="keyword">sizeof</span>(RXN_RefLocation_t));
 RefLoc.format = RXN_LOC_LLA;
 RefLoc.LLA.Lat = 49.28381;       <span class="comment">// RXN Office</span>
 RefLoc.LLA.Lon = -123.10463;     <span class="comment">// RXN Office</span>
 RefLoc.LLA.Alt = 10.60308;       <span class="comment">// RXN Office</span>

 <span class="comment">// Wait on a restart (by polling, waiting for an event, msg, interrupt, etc). Very high level</span>
 eg code below.
 <span class="keywordflow">if</span>(RestartPerformed)
 {
    <span class="comment">// Setup ref time data.</span>
    RXN_RefTime_t RefTime;
    memset((<span class="keywordtype">void</span>*) &amp;RefTime, 0, <span class="keyword">sizeof</span>(RXN_RefTime_t));
    RefTime.weekNum = CL_GetGPSWeekNum();  <span class="comment">// CL_GetGPSWeekNum() is util fcn supported within the CL.</span>
    RefTime.TOWmSec = CL_GetGPSTOW();      <span class="comment">// CL_GetGPSTOW() is a util fcn supported within the CL.</span>
    RefTime.TOWnSec = 0;
    RefTime.TAccmSec = 0;
    RefTime.TAccnSec = 0;

    <span class="comment">// Set the reference time and location.</span>
    <span class="keywordflow">if</span>(<a class="code" href="RXN__CL_8h.html#a72527b125130326a68f1bc1331309ef1" title="Set a reference location and/or time within the chipset.">RXN_CL_SetRefLocTime</a>(handle, &amp;RefLoc, &amp;RefTime) != RXN_SUCCESS)
    {
        <span class="comment">// ToDo: Handle error.</span>
    }
 }
 <span class="keywordflow">else</span>
 {
    <span class="comment">// ToDo: Loop back to check for restart.</span>
 }
</pre></div> 
</div>
</div>
<a class="anchor" id="af0c5d6d1b7b92d394c3287b97f38f5f9"></a><!-- doxytag: member="RXN_CL.h::RXN_CL_Uninitialize" ref="af0c5d6d1b7b92d394c3287b97f38f5f9" args="(U16 handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U16 RXN_CL_Uninitialize </td>
          <td>(</td>
          <td class="paramtype">U16&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>UnInitialize a CL library instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>[IN] A handle that identifies a CL instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RXN_SUCCESS if the CL is uninitialized successfully. </dd>
<dd>
RXN_CL_INSTANCE_NOT_FOUND_ERR if an instance corresponding the provided handle cannot be found. </dd>
<dd>
RXN_CL_OPEN_OR_CLOSE_ERR if a port could not be closed properly.</dd></dl>
<p><b>Description</b><br/>
 Shut down a previously initialized CL instance to free up instances and resources for subsequent use.</p>
<p><b>See Also</b><br/>
 <a class="el" href="RXN__CL_8h.html#a92e14faace538133eae58594f2aa4907" title="Initialize the CL library for use with a specific chipset and version of chipset...">RXN_CL_Initialize()</a></p>
<p><b>Example Usage</b> </p>
<div class="fragment"><pre class="fragment"> See the example code provided <span class="keywordflow">for</span> <a class="code" href="RXN__CL_8h.html#a92e14faace538133eae58594f2aa4907" title="Initialize the CL library for use with a specific chipset and version of chipset...">RXN_CL_Initialize</a>().
</pre></div> 
</div>
</div>
<a class="anchor" id="a0680122568e9398d1a05abefd34faee3"></a><!-- doxytag: member="RXN_CL.h::RXN_CL_Work" ref="a0680122568e9398d1a05abefd34faee3" args="(U16 handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U16 RXN_CL_Work </td>
          <td>(</td>
          <td class="paramtype">U16&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Give the chipset CL implementation time to perform periodic tasks. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>[IN] A handle that identifies a CL instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RXN_SUCCESS if work is performed successfully. </dd>
<dd>
RXN_CL_INSTANCE_NOT_FOUND_ERR if the handle provided does not support an open CL instance. </dd>
<dd>
RXN_CL_OPEN_OR_CLOSE_ERR if a port supporting access to the chipset has not been opened. (chipsets with protocol interface only). </dd>
<dd>
RXN_CL_CHIPSET_READ_ERR if a chipset read error occurred (chipsets with protocol interface only). </dd>
<dd>
RXN_CL_CHIPSET_WRITE_ERR if a chipset read error occurred (chipsets with protocol interface only). </dd>
<dd>
RXN_CL_MSG_PARSE_ERROR if a chipset msg parse occurred (chipsets with protocol interface only). </dd>
<dd>
RXN_CL_MSG_NACK_ERROR if a chipset msg is nack'd (chipsets with protocol interface only).</dd></dl>
<p><b>Description</b><br/>
 The RXN_CL_Work function is intended to support CL implementations that require periodic processing (e.g. to poll looking for ephemeris to see if a restart occurred, or for hosted chipset libraries - perform internal work). Applications consuming any CL implementation requiring periodic processing should call this function on a periodic basis. This periodic processing will not be implemented within threads spawned from CL implementation code as such threads would break the CL's requirement for single threaded app support.</p>
<p><b>Notes:</b> </p>
<ul>
<li>
CL consumers should call this work function at period no greater than 50mSec. This requirement will ensure that any CL implementation requiring very periodic processing can be supported. </li>
<li>
If any CL implementation has a min periodicity requirement, that implementation should "Sleep" within it's CL <a class="el" href="RXN__CL_8h.html#a0680122568e9398d1a05abefd34faee3" title="Give the chipset CL implementation time to perform periodic tasks.">RXN_CL_Work()</a> implementation to satisfy this requirement. (E.g. CL implementation requires that its work function be called with cycle time of no less than 100 mSec. CL implementation should keep track of the tick count at the beginning of each CL <a class="el" href="RXN__CL_8h.html#a0680122568e9398d1a05abefd34faee3" title="Give the chipset CL implementation time to perform periodic tasks.">RXN_CL_Work()</a> call and sleep the requried number of mSec to ensure that internally, functions are not called more than every 100mSec. </li>
</ul>
<p><b>Example Usage</b> </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Application&#39;s main thread, or spawed thread (if permitted).</span>
 <span class="keywordflow">while</span>(<span class="keyword">true</span>)
 {
    <span class="comment">// Give the CL implementation cycles to do its work.</span>
    <a class="code" href="RXN__CL_8h.html#a0680122568e9398d1a05abefd34faee3" title="Give the chipset CL implementation time to perform periodic tasks.">RXN_CL_Work</a>();

    <span class="comment">// Do other periodic tasks.</span>

    <span class="comment">// Ensure that other tasks have cycles and don&#39;t call</span>
    <span class="comment">// RXN_CL_Work() too frequently. Sleep the thread for 40 mSec.</span>
    Sleep(40);
 }
</pre></div> 
</div>
</div>
<a class="anchor" id="a8b09f50528981195bd1b115b7692b050"></a><!-- doxytag: member="RXN_CL.h::RXN_CL_WriteEphemeris" ref="a8b09f50528981195bd1b115b7692b050" args="(U16 handle, RXN_MSL_NavDataList_t *pNavDataList, RXN_constel_t constel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U16 RXN_CL_WriteEphemeris </td>
          <td>(</td>
          <td class="paramtype">U16&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RXN_MSL_NavDataList_t *&nbsp;</td>
          <td class="paramname"> <em>pNavDataList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RXN_constel_t&nbsp;</td>
          <td class="paramname"> <em>constel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write extended ephemeris data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>[IN] A handle that identifies a CL instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pNavDataList</em>&nbsp;</td><td>[IN] A pointer to a RXN_MSL_NavDataList_t struct that is populated with ephemeris data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>constel</em>&nbsp;</td><td>[IN] The constellation</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RXN_SUCCESS if ephemeris is written successfully. </dd>
<dd>
RXN_CL_INSTANCE_NOT_FOUND_ERR if the handle provided does not support an open CL instance. </dd>
<dd>
RXN_CL_NO_CHIPSET_SUPPORT_ERR if the chipset selected within <a class="el" href="RXN__CL_8h.html#a92e14faace538133eae58594f2aa4907" title="Initialize the CL library for use with a specific chipset and version of chipset...">RXN_CL_Initialize()</a> does not support this function. </dd>
<dd>
RXN_CL_OPEN_OR_CLOSE_ERR if a port supporting access to the chipset has not been opened. </dd>
<dd>
RXN_CL_CHIPSET_WRITE_ERR if a request msg could not be sent to the chipset. </dd>
<dd>
RXN_CL_CHIPSET_READ_ERR if a response msg could not be read from the chipset. </dd>
<dd>
RXN_CL_CHIPSET_READ_TIMEOUT if a timeout occurred while waiting for a chipset msg. </dd>
<dd>
RXN_CL_MSG_NACK_ERROR if a write request is nacked. </dd>
<dd>
RXN_CL_ALLOCATION_ERROR if the array size specified is invalid (&lt; 1 or &gt; 32).</dd></dl>
<p><b>Description</b><br/>
 Write an array of extended ephemeris (EE) data structs through a previously initialized CL instance.</p>
<p><b>Notes:</b> </p>
<ul>
<li>
To convert ephemeris that is acquired from Rx Networks GPStream products from RXN_ephem_t to RXN_FullEph_t, utilize the <a class="el" href="RXN__CL_8h.html#aadbe9bfd94f7536dbcd53c4db691feaa" title="Convert ephemeris data (RXN ephemeris to full ephemeris).">RXN_CL_RXNToFull()</a> function. </li>
<li>
It is expected that all PRNArr records will contain valid ephemeris data. CL consumers will not have to validate whether a PRNArr element contains valid data by checking that the "prn" is non-zero. </li>
</ul>
<p><b>See Also</b><br/>
 <a class="el" href="RXN__CL_8h.html#ae417df1e3e41fcb71ade1b34d2e82058" title="Read broadcast ephemeris data.">RXN_CL_ReadEphemeris()</a>, <a class="el" href="RXN__CL_8h.html#aadbe9bfd94f7536dbcd53c4db691feaa" title="Convert ephemeris data (RXN ephemeris to full ephemeris).">RXN_CL_RXNToFull()</a></p>
<p><b>Example Usage</b> </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// ToDo: Initialize a CL instance for use. See RXN_CL_Initialize() example usage.</span>
 <span class="comment">// Initialization will yield a &quot;handle&quot; for use within the RXN_CL_Restart() call below.</span>

 <span class="comment">// Setup an array for ephemeris data store.</span>
 RXN_FullEphem_u PRNEphArr[RXN_CONSTANT_NUM_PRNS];

 <span class="comment">// ToDo: Populate PRNEphArr utilizing an Rx Networks GPStream API.</span>

 <span class="comment">// Write ephemeris into a chipset from pNavDataList.</span>
 <span class="keywordflow">if</span>(<a class="code" href="RXN__CL_8h.html#a8b09f50528981195bd1b115b7692b050" title="Write extended ephemeris data.">RXN_CL_WriteEphemeris</a>(handle, pNavDataList, RXN_GPS_CONSTEL) != RXN_SUCCESS)
 {
    <span class="comment">// ToDo: Handle error.</span>
 }
</pre></div> 
</div>
</div>
</div>
<hr size="1"><address style="text-align: left;">
<br/>
<a href="http://www.rxnetworks.ca" target="_blank"><img border="0" src="rxn-logo.png"/></a><br/><br/>
Copyright (c) 2007-2010 Rx Networks, Inc. All rights reserved.<br/>
<br/>
Property of Rx Networks<br/>
Proprietary and Confidential<br/>
<br/>
Any use, distribution, or copying of this document requires a 
license agreement with Rx Networks. 
Any product development based on the contents of this document 
requires a license agreement with Rx Networks.<br/>
<br/>
<hr size="1"><address style="text-align: right;"><small>
Generated on Wed Jun 4 14:23:31 2014 for GPStream Chipset Library by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.6.3</small></address>
</body>
</html>
